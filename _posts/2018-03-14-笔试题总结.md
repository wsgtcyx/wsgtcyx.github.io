---
layout:     post
title:      算法笔试题总结
subtitle:   keep practicing！
date:       2018-03-14
author:     CHEN	Yuxiang
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - python
---



# part1 sorting ***********
### 1.插入排序

```python 
def insert_sort(lists):
	count = len(lists)
	for I in range(1,count):
		key=lists[I]
		j=i-1
		while j>=0:
			if lists[j]>key:
				lists[j+1] = lists[j]
				lists[j]=key
				j -=1
			else:
				break
	return lists
```

### 2.希尔排序

```python
def shell_sort(lists):
	count = len(lists)
	step = 2
	group = count/step
	while group>0:
		for I in range(0,group):
			j = I + group
			while  j < count:
				key= lists[j]
				k = j - group
				while k>=0:
					if lists[k]>key:
						lists[k+group] = lists[k]
						lists[k] = key
						k -= group
					else:
						break
				j += group
		group /=step
	return lists
```

### 3 冒泡排序

描述

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

```python
def bubble_sort(lists):
	count = len(lists)
	for I in range(0,count):
		for j in range(I+1,count):
			if lists[I]>lists[j]:
				lists[I],lists[j]=lists[j],lists[I]
	return lists
```
### 4 快速排序
描述

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。


```python
def quick_sort(lists,left,right):
	if left >=right:
		return lists

	key = lists[left]
	low = left
	high = right

	while left<right:
		while left<right and lists[right]>=key:
			right -=1
		lists[left]=lists[right]
		while left<right and lists[left]<=key:
			left +=1
		lists[right]=lists[left]
	#now left==right
	lists[right] = key
	quick_sort(lists,low,left-1)
	quick_sort(lists,right+1,high)
	return lists
```

### 5 选择排序

```python
def select_sort(lists):
	count = len(lists)
	for i in range(0,count):
		min_index = i
		for j in range(i+1,count):
			if lists[min_index]>lists[j]:
				min_index=j
		lists[min_index],lists[i]=lists[i],lists[min_index]
	return lists
```

### 6 堆排序

描述

堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。

```python
def MAX_Heapify(heap,HeapSize,root):  # 下滤
	left = 2*root+1
	right  = left +1
	larger = root
	if left<HeapSize and heap[larger]<heap[left]:
		larger=left
	if  right<HeapSize and heap[larger]<heap[right]:
		larger=right
	if larger!=root: #如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
		heap[larger],heap[root]=heap[root],heap[larger]
		MAX_Heapify(heap,HeapSize,larger)


def Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序
	HeapSize = len(heap)
	for i in range((HeapSize-2)/2,-1,-1): #从后往前出数
		MAX_Heapify(heap,HeapSize,i)



def HeapSort(heap):
	Build_MAX_Heap(heap)
	for i in range(len(heap)-1,-1,-1): #将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。
		heap[0],heap[i] = heap[i],heap[0]
		MAX_Heapify(heap,i,0)
	return heap
```

### 7 归并排序

描述

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

```python
def merge(left,right):
	i=j=0
	result = []
	while i <len(left) and j<len(right):
		if left[i]<=right[j]:
			result.append(left[i])
			i+=1
		else:
			result.append(right[j])
			j +=1
	result += left[i:]
	result += right[j:]
	return result
def merge_sort(lists):
	if len(lists)<=1:
		return lists
	num = len(lists)/2
	left = merge_sort(lists[:num])
	right = merge_sort(lists[num:])
	return merge(left,right)
```

### 基数排序（桶排序）

# part2 DP题  ***********

### 丑数

把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

```python
#动态规划，递推关系：k[i] = min(k[t2]*2, k[t3]*3, k[t5]*5)

class Solution:
    def GetUglyNumber_Solution(self, index):
        if index==0:
            return 0
        if index==1:
            return 1

        t2=t3=t5=0
        numbers=[1]*index
        for i in range(1,index):
            numbers[i]=min(numbers[t2]*2,numbers[t3]*3,numbers[t5]*5)
            if numbers[i] ==numbers[t2]*2:
                t2 +=1
            if numbers[i]==numbers[t3]*3:
                t3 +=1
            if numbers[i]==numbers[t5]*5:
                t5 +=1

        return numbers[index-1]
```

### 最大连续乘积子串(动态规划)

[讲解](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/05.01.html)

```python
def MaxProductSubstring(a):
	if a==None or len(a)==0:
		return 0

	maxEnd = minEnd = maxResult = a[0]
	for i in range(1,len(a)):
		end1 = maxEnd * a[i]
		end2 = maxEnd * a[i]

		maxEnd = max(max(end1,end2),a[i])
		minEnd = min(min(end1,end2),a[i]) # 因为是负数 但绝对值最大
		maxResult=max(maxResult,maxEnd)
	return maxResult
```

### 字符串编辑距离

题目描述

给定一个源串和目标串，能够对源串进行如下操作：

* 在给定位置上插入一个字符
* 替换任意字符
* 删除任意字符

写一个程序，返回最小操作数，使得对源串进行这些操作后等于目标串，源串和目标串的长度都小于2000。

```python
def EditDistance(source,target):
	lenS = len(source)
	lenT = len(target)

	DP = [[0]*(lenT+1)]*(lenT+1)

	for i in range(lenS+1):
		DP[i][0]=i
	for j in range(lenT+1):
		DP[0][j]=j

	for i in range(1,lenS+1):
		for j in range(1,lenT+1):
			if source[i-1]==target[j-1]:
				DP[i][j] = DP[i-1][j-1]
			else:
				DP[i][j]=1+min(DP[i-1][j],DP[i][j-1])
	return DP[lenS][lenT]
```
### 交叉字符串
给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。

```python
class Solution:
    """
    @param s1: A string
    @param s2: A string
    @param s3: A string
    @return: Determine whether s3 is formed by interleaving of s1 and s2
    """
    def isInterleave(self, s1, s2, s3):
        # write your code here
        if not s1 or not s2 or not s3:
        	return False
        if len(s1)+len(s2)!=len(s3):
        	return False

        f =[[False]*(len(s2)+1) for i in range(len(s1)+1)]
        f[0][0] = True

        for i in range(1,len(s1)+1):
        	f[i][0]=  s1[:i]==s3[:i]
        for i in range(1,len(s2)+1):
        	f[0][i]=  s2[:i]==s3[:i]

        for i in range(1,len(s1)+1):
        	for j in range(1,len(s2)+1):
        		if s1[i-1]==s3[i+j-1]:
        			f[i][j] = f[i-1][j]
        		if s2[j-1]==s3[i+j-1]:
        			f[i][j] = f[i][j-1]

        return f[-1][-1]

if __name__=="__main__":
	#N,M = map(int, raw_input().split())
	A= Solution()
	s1 = "aabcc" 
	s2 = "dbbca"
	s3= "aadbbcbcac"

	print A.isInterleave(s1,s2,s3)
```




### 01背包问题

```python
# -*- coding:utf-8 -*-

def easy_package(weight,value,package):
	N = len(weight)
	M=package

	weight.insert(0,0)
	value.insert(0,0)

	f = [[0]*(M+1)]*(N+1)  #NxM matrix
	for i in range(1,N+1):
		for j in range(1,M+1):
			if weight[i]<=j:
				f[i][j]=max(f[i-1][j],f[i-1][j-weight[i]]+value[i])
			else:
				f[i][j] = f[i-1][j]
	return f[N][M]

#  w[i]：第i个物体的重量 
# - p[i]：第i个物体的价值 
# - f[i][j]：前i个物体放入容量为j 包的最大价值 
# - f[i-1][j]：前i个物体放入容量为j 包的最大价值 
# - f[i-1][j-w[i]]：前i-1个物体放入容量为j-w[i] 包的最大价值

# f[i][j]=max{f[i-1][j-w[i]]+v[i]（j>=w[i]） , f[i-1][j]} 

if __name__=="__main__":

	weight = [2,2,6,5,4]
	value  = [6,3,5,4,6]
	package = 10
	print easy_package(weight,value,package)

```

### 优化空间后的 01背包问题

```python
# -*- coding:utf-8 -*-

def easy_package(weight,value,package):
	N = len(weight)
	M=package

	weight.insert(0,0)
	value.insert(0,0)
	f = [0]*(M+1)  #(M+1) matrix
	for i in range(1,N+1):
		for m in range(0,M+1)[::-1]:
			if m>= weight[i]:
				f[m] = max(f[m],f[m-weight[i]]+value[i])

	return f[M]


# 先考虑一下上面的状态转移方程如何实现
# 肯定有一个主循环i = 1...N,每次算出来二维数组dp[i][0..V]的所有值。
# 那么如果只用一个数组f[0...V],能不能保证第i次循环结束后f[v]就是我们定义的状态f[i][v]呢？
# f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，
# 能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？
# 事实上，这要求在每次主循环中我们以v=V...0的顺序推f[v]，
# 这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。

if __name__=="__main__":

	weight = [2,2,6,5,4]
	value  = [6,3,5,4,6]
	package = 10
	print easy_package(weight,value,package)
```

### 完全背包问题

题目

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价格是w[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

转化为01背包求解

最简单的想法是：考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转换为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。但是这样完全没有改进时间复杂度，但这毕竟给了我们将完全背包转换为01背包问题的思路：将一种物品拆成多件物品

O(VN)的算法

``` cpp
for I = 1 ... N  
    for v = 0 ... V  
        f[v] = max{f[v], f[v-cost] + weight}  
```
        
你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就行呢？首先，想想为什么01背包问题中要按照v=V...0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰好是每种物品可选无限件，所以在考虑“加选一件dii种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][c-v[i]],所以就可以并且必须采用v=0...V的顺序循环

```python
def solve3(vlist,wlist,totalWeight,totalLength):
    """完全背包问题"""
    resArr = np.zeros((totalWeight)+1,dtype=np.int32)
    for i in range(1,totalLength+1):
        for j in range(1,totalWeight+1):
            if wlist[i] <= j:
                resArr[j] = max(resArr[j],resArr[j-wlist[i]]+vlist[i])
    return resArr[-1]

if __name__ == '__main__':
    v = [0,60,100,120]
    w = [0,10,20,30]
    weight = 50
    n = 3
    result = solve3(v,w,weight,n)
    print(result)
```


### （硬币问题） 动态规划 (其实是完全背包问题)

如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)

d(i)=min{ d(i-vj)+1 }，其中 i-vj >=0，vj表示第 j 个硬币的面值;

```python
Min=[x for x in range(12)];
VN=[1,3,5];
for i in range(1,12,1):
    for j in range(3):
        if VN[j]<=i and Min[i-VN[j]]+1<Min[i]:
            Min[i]=Min[i-VN[j]]+1;
 
print(Min[1::1]);
```

### LIS 问题
一个序列有 N 个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲 DP 基本都会讲到的一个问题 LIS：longest increasing subsequence)

```python
定义 d(i)，表示前 i 个数中以 A[i]结尾的最长非降子序列的长度
d(i) = max{1, d(j)+1},其中 j<i,A[j]<=A[i]

def LIS(nums):
	d = [0]*len(nums)
	answer = 1
	for i in range(len(nums)):
		d[i]=1
		for j in range(i):
			if nums[j]<=nums[i] and (d[j]+1)>d[i]:
				d[i] = d[j]+1

	answer = max(d)
	return answer

if __name__=="__main__":

	data = [5,3,4,8,6,7]
	print LIS(data)
```

### 最长公共子序列 LCS（longest common sequence） 问题

```
c[i,j]表示Xi 和 Yj 的LCS的长度

c[i,j]= 0 if(I or j ==0)
      = c[I-1,j-1]+1. If x[I]=y[j]
      = max(c[I-1][j],c[I][j-1]).   If x[I]!=y[j]
```

```python
def LCS(s1,s2):
	length1 = len(s1)
	length2 = len(s2)

	s1.insert(0,0)
	s2.insert(0,0)

	c = [[0]*(length2+1)]*(length1+1)
	for i in range(1,len(c)):
		for j in range(1,len(c[0])):
			if s1[i]==s2[j]:
				c[i][j] = c[i-1][j-1]+1
			else:
				c[i][j] = max(c[i-1][j],c[i][j-1])

	return c[-1][-1]

if __name__=="__main__":

	s1=[1,3,4,5,6,7,7,8]
	s2=[3,5,7,4,8,6,7,8,2]
	
	print LCS(s1,s2)
```


### 划分单词问题

给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。

样例

给出

```
s = "lintcode"

dict = ["lint","code"]
```

返回 true 因为"lintcode"可以被空格切分成"lint code"

```python
class Solution:
    """
    @param: s: A string
    @param: dict: A dictionary of words dict
    @return: A boolean
    """
    def wordBreak(self, s, dict):
        # write your code here
        # f[i] means that until i ,it can be break into dict words
        # f[i] is true if f[I-j]is true and f[I-j:i] is in dict (1<=j<=min(maxlength,i))
        if len(dict)==0:
        	return len(s) == 0

        n = len(s)
        f = [False] *(n+1)
        f[0] = True

        maxLength = max([len(w) for w in dict])
        for i in range(1,n+1):
        	for j in range(1,min(maxLength,i)+1):
        	    
        		if not f[i-j]:
        			continue

        		if s[i-j:i] in dict:
        			f[i] = True
        			break
        return f[n]
```

# part3. 树题 ***********


### 不同的二叉查找树（动态规划）
给出 n，问由 1...n 为节点组成的不同的二叉查找树有多少种？

```python 
class Solution:
    """
    @param n: An integer
    @return: An integer
    """
    def numTrees(self, n):
#The case for 3 elements example
# Count[3] = Count[0]*Count[2]  (1 as root)
#            + Count[1]*Count[1]  (2 as root)  左边有几个数字 右边有几个数字
#            + Count[2]*Count[0]  (3 as root)

# Therefore, we can get the equation:
# Count[i] = ∑ Count[0...k] * count[ k+1....i]     0<=k<i-1  
        maxType = [1,1,2]
        if n<=2:
        	return maxType[n]

        maxType = maxType+[0]*(n-2)

        for i in range(3,n+1):
        	for j in range(0,i):
        		maxType[i] += maxType[j]*maxType[i-j-1]

        return maxType[-1]
```

### 最近公共祖先LCA问题

问题描述

求有根树的任意两个节点的最近公共祖先。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def getLCA(root,node1,node2):
	if root==None:
		return None
	if root==node1 or root==node2: 
		return root

	left = getLCA(root.left,node1,node2)
	right = getLCA(root.right,node1,node2)

	if(left!=None and right!=None):
		return root
	elif left!=None:
		return left
	elif right!=None:
		return right
	else:
		return None
```
若为**二叉搜索树的话(BST)**

二叉搜索树是经过排序的，位于左子树的节点都比父节点小，位于右子树的节点都比父节点大。既然要找最低的公共祖先节点，我们可以从根节点开始进行比较。

若当前节点的值比两个节点的值都大，那么最低的祖先节点一定在当前节点的左子树中，则遍历当前节点的左子节点；

反之，若当前节点的值比两个节点的值都小，那么最低的祖先节点一定在当前节点的右子树中，则遍历当前节点的右子节点；

这样，直到找到一个节点，位于两个节点值的中间，则找到了最低的公共祖先节点。

```python
def getLCA(root,node1,node2):
	if root==None or root==node1 or root==node2:
		return root

	if root.val > max(node1.val,node2,val):
		return getLCA(root.left,node1,node2)
	elif root.val < min(node1.val,node2.val):
		return getLCA(root.right,node1,node2)
	else:
		return root
```

### 二叉树的深度
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```python
class Solution:
    def TreeDepth(self, pRoot):
        # write code here
        if pRoot is None:
            return 0

        else:
            left_deepth=self.TreeDepth(pRoot.left)
            right_deepth=self.TreeDepth(pRoot.right)
            return max(left_deepth,right_deepth)+1
```
     
### 树的子结构
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```python
# -*- coding:utf-8 -*-
class TreeNode:
     def __init__(self, x):
         self.val = x
         self.left = None
         self.right = None


class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        if pRoot2==None or pRoot1==None:
            return False

        if self.judgeSame(pRoot1,pRoot2):
            return True
        else:
            result1=self.HasSubtree(pRoot1.left,pRoot2)
            result2=self.HasSubtree(pRoot1.right,pRoot2)
            result=result1 or result2
        return result


    def judgeSame(self,pRoot1, pRoot2):
        if pRoot2==None:
            return True

        if(pRoot1!=None and pRoot2==None):
            return False
        if (pRoot2 != None and pRoot1 == None):
            return False

        if(pRoot1.val!=pRoot2.val):
            return False
        return  self.judgeSame(pRoot1.left,pRoot2.left) and self.judgeSame(pRoot1.right,pRoot2.right)
        
 ```
 
### 重建二叉树

题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```python
# -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if(len(pre)==0) or(len(tin)==0)：
        	return None

        rootValue = pre[0]
        root = TreeNode(rootValue)

        if len(pre)==1:
        	return root

        rootTinIndex = tin.index(rootValue)
        preStart = 1
        preEnd = rootTinIndex + 1  
        tinStart = 0
        tinEnd = rootTinIndex

        if rootTinIndex>0:
        	root.left = self.reConstructBinaryTree(pre[preStart:preEnd],tin[tinStart:tinEnd])
        if rootTinIndex<(len(pre)-1):
        	root.right =self.reConstructBinaryTree(pre[preEnd+1:],tin[tinEnd+1:])
        return root


if __name__=="__main__":


	A = Solution()

	pre = [1,2,4,7,3,5,6,8]
	tin = [4,7,2,1,5,3,8,6]
	print A.reConstructBinaryTree(pre,tin)
```

# part4 遍历与查找 ***********

### 字符串的任意全排列问题
```python
def all_permulation(result,data,length):# 字符串的全排列 采用DFS思想
	if len(result)==length:
		global possible_answer
		possible_answer.append(result[:])
		return

	for i in range(len(data)):
		result.append(data[i])
		all_permulation(result,data[:i]+data[i+1:],length)
		result.pop(-1)
	return

if __name__=="__main__":

	data= ['a','b','c','d']

	possible_answer=[]

	all_permulation([],data,len(data))
	print possible_answer
	print len(possible_answer)

```


### 二分查找 
注意index2 的初始值和while的判断条件

```python

def BinarySearch(data,number):
	if (data == None) or len(data)==0:
		return False

	index1=0
	index2=len(data)
	while(index1<=index2):
		indexMid = (index1+index2)/2
		if data[indexMid]>number:
			index2 = indexMid

		elif data[indexMid]<number:
			index1 = indexMid
		else:
			return True
	return False
```

# part5 线性数据结构

### 反转链表
```python
# -*- coding:utf-8 -*-
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        pNew=None
        pCur=pHead
        while(pCur!=None):
        	pHead = pCur.next
        	pCur.next=pNew
        	pNew=pCur
        	pCur=pHead
        return pNew

```

### 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

其实zip还是反过来会这个二维数组操作，但要注意写成zip(*)，表示这是一个zip的逆操作。

```python
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        if matrix==None or len(matrix)==0:
            return None
        a=[]

        while matrix:
            a.extend(list(matrix.pop(0)))
            matrix=zip(*matrix)
            matrix.reverse()
        return a

```



















