---
layout:     post
title:      算法笔试题总结
subtitle:   keep practicing！
date:       2018-03-14
author:     CHEN	Yuxiang
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - python
---

# part1 sorting
### 1.插入排序

```python 
def insert_sort(lists):
	count = len(lists)
	for I in range(1,count):
		key=lists[I]
		j=i-1
		while j>=0:
			if lists[j]>key:
				lists[j+1] = lists[j]
				lists[j]=key
				j -=1
			else:
				break
	return lists
```

### 2.希尔排序

```python
def shell_sort(lists):
	count = len(lists)
	step = 2
	group = count/step
	while group>0:
		for I in range(0,group):
			j = I + group
			while  j < count:
				key= lists[j]
				k = j - group
				while k>=0:
					if lists[k]>key:
						lists[k+group] = lists[k]
						lists[k] = key
						k -= group
					else:
						break
				j += group
		group /=step
	return lists
```

### 3 冒泡排序

描述

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

```python
def bubble_sort(lists):
	count = len(lists)
	for I in range(0,count):
		for j in range(I+1,count):
			if lists[I]>lists[j]:
				lists[I],lists[j]=lists[j],lists[I]
	return lists
```
### 4 快速排序
描述

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。


```python
def quick_sort(lists,left,right):
	if left >=right:
		return lists

	key = lists[left]
	low = left
	high = right

	while left<right:
		while left<right and lists[right]>=key:
			right -=1
		lists[left]=lists[right]
		while left<right and lists[left]<=key:
			left +=1
		lists[right]=lists[left]
	#now left==right
	lists[right] = key
	quick_sort(lists,low,left-1)
	quick_sort(lists,right+1,high)
	return lists
```

### 5 选择排序

```python
def select_sort(lists):
	count = len(lists)
	for i in range(0,count):
		min_index = i
		for j in range(i+1,count):
			if lists[min_index]>lists[j]:
				min_index=j
		lists[min_index],lists[i]=lists[i],lists[min_index]
	return lists
```

3.6 堆排序
描述
堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。


def MAX_Heapify(heap,HeapSize,root):  # 下滤
	left = 2*root+1
	right  = left +1
	larger = root
	if left<HeapSize and heap[larger]<heap[left]:
		larger=left
	if  right<HeapSize and heap[larger]<heap[right]:
		larger=right

	if larger!=root: #如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作
		heap[larger],heap[root]=heap[root],heap[larger]
		MAX_Heapify(heap,HeapSize,larger)


def Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序
	HeapSize = len(heap)
	for i in range((HeapSize-2)/2,-1,-1): #从后往前出数
		MAX_Heapify(heap,HeapSize,i)



def HeapSort(heap):
	Build_MAX_Heap(heap)
	for i in range(len(heap)-1,-1,-1): #将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。
		heap[0],heap[i] = heap[i],heap[0]
		MAX_Heapify(heap,i,0)
	return heap

3.7 归并排序
描述
归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
def merge(left,right):
	i=j=0
	result = []
	while i <len(left) and j<len(right):
		if left[i]<=right[j]:
			result.append(left[i])
			i+=1
		else:
			result.append(right[j])
			j +=1
	result += left[i:]
	result += right[j:]
	return result
def merge_sort(lists):
	if len(lists)<=1:
		return lists
	num = len(lists)/2
	left = merge_sort(lists[:num])
	right = merge_sort(lists[num:])
	return merge(left,right)

## 基数排序（桶排序）



1. 二分查找 
注意index2 的初始值和while的判断条件
def BinarySearch(data,number):
	if (data == None) or len(data)==0:
		return False

	index1=0
	index2=len(data)
	while(index1<=index2):
		indexMid = (index1+index2)/2
		if data[indexMid]>number:
			index2 = indexMid

		elif data[indexMid]<number:
			index1 = indexMid
		else:
			return True
	return False

2.最大连续乘积子串(动态规划)
def MaxProductSubstring(a):
	if a==None or len(a)==0:
		return 0

	maxEnd = minEnd = maxResult = a[0]
	for i in range(1,len(a)):
		end1 = maxEnd * a[i]
		end2 = maxEnd * a[i]

		maxEnd = max(max(end1,end2),a[i])
		minEnd = min(min(end1,end2),a[i]) # 因为是负数 但绝对值最大
		maxResult=max(maxResult,maxEnd)
	return maxResult

3. 字符串编辑距离
题目描述
给定一个源串和目标串，能够对源串进行如下操作：
在给定位置上插入一个字符
替换任意字符
删除任意字符
写一个程序，返回最小操作数，使得对源串进行这些操作后等于目标串，源串和目标串的长度都小于2000。


def EditDistance(source,target):
	lenS = len(source)
	lenT = len(target)

	DP = [[0]*(lenT+1)]*(lenT+1)

	for i in range(lenS+1):
		DP[i][0]=i
	for j in range(lenT+1):
		DP[0][j]=j

	for i in range(1,lenS+1):
		for j in range(1,lenT+1):
			if source[i-1]==target[j-1]:
				DP[i][j] = DP[i-1][j-1]
			else:
				DP[i][j]=1+min(DP[i-1][j],DP[i][j-1])
	return DP[lenS][lenT]


3. 常见排序实现


4.最近公共祖先LCA问题


问题描述
求有根树的任意两个节点的最近公共祖先。
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def getLCA(root,node1,node2):
	if root==None:
		return None
	if root==node1 or root==node2: 
		return root

	left = getLCA(root.left,node1,node2)
	right = getLCA(root.right,node1,node2)

	if(left!=None and right!=None):
		return root
	elif left!=None:
		return left
	elif right!=None:
		return right
	else:
		return None

5.字符串的任意全排列问题
def all_permulation(result,data,length):# 字符串的全排列 采用DFS思想
	if len(result)==length:
		global possible_answer
		possible_answer.append(result[:])
		return

	for i in range(len(data)):
		result.append(data[i])
		all_permulation(result,data[:i]+data[i+1:],length)
		result.pop(-1)
	return

if __name__=="__main__":

	data= ['a','b','c','d']

	possible_answer=[]

	all_permulation([],data,len(data))
	print possible_answer
	print len(possible_answer)


6. 01背包问题
# -*- coding:utf-8 -*-

def easy_package(weight,value,package):
	N = len(weight)
	M=package

	weight.insert(0,0)
	value.insert(0,0)

	f = [[0]*(M+1)]*(N+1)  #NxM matrix
	for i in range(1,N+1):
		for j in range(1,M+1):
			if weight[i]<=j:
				f[i][j]=max(f[i-1][j],f[i-1][j-weight[i]]+value[i])
			else:
				f[i][j] = f[i-1][j]
	return f[N][M]

#  w[i]：第i个物体的重量 
# - p[i]：第i个物体的价值 
# - f[i][j]：前i个物体放入容量为j 包的最大价值 
# - f[i-1][j]：前i个物体放入容量为j 包的最大价值 
# - f[i-1][j-w[i]]：前i-1个物体放入容量为j-w[i] 包的最大价值

# f[i][j]=max{f[i-1][j-w[i]]+v[i]（j>=w[i]） , f[i-1][j]} 

if __name__=="__main__":

	weight = [2,2,6,5,4]
	value  = [6,3,5,4,6]
	package = 10
	print easy_package(weight,value,package)

6.2 优化空间后的 01背包问题
# -*- coding:utf-8 -*-

def easy_package(weight,value,package):
	N = len(weight)
	M=package

	weight.insert(0,0)
	value.insert(0,0)
	f = [0]*(M+1)  #(M+1) matrix
	for i in range(1,N+1):
		for m in range(0,M+1)[::-1]:
			if m>= weight[i]:
				f[m] = max(f[m],f[m-weight[i]]+value[i])

	return f[M]

# 先考虑一下上面的状态转移方程如何实现
# 肯定有一个主循环i = 1...N,每次算出来二维数组dp[i][0..V]的所有值。
# 那么如果只用一个数组f[0...V],能不能保证第i次循环结束后f[v]就是我们定义的状态f[i][v]呢？
# f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，
# 能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？
# 事实上，这要求在每次主循环中我们以v=V...0的顺序推f[v]，
# 这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。

if __name__=="__main__":

	weight = [2,2,6,5,4]
	value  = [6,3,5,4,6]
	package = 10
	print easy_package(weight,value,package)


7. （硬币问题） 动态规划
如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)

d(i)=min{ d(i-vj)+1 }，其中 i-vj >=0，vj表示第 j 个硬币的面值;

Min=[x for x in range(12)];
VN=[1,3,5];
for i in range(1,12,1):
    for j in range(3):
        if VN[j]<=i and Min[i-VN[j]]+1<Min[i]:
            Min[i]=Min[i-VN[j]]+1;
 
print(Min[1::1]);

8. LIS 问题
一个序列有 N 个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲 DP 基本都会讲到的一个问题 LIS：longest increasing subsequence)

定义 d(i)，表示前 i 个数中以 A[i]结尾的最长非降子序列的长度
d(i) = max{1, d(j)+1},其中 j<i,A[j]<=A[i]

def LIS(nums):
	d = [0]*len(nums)
	answer = 1
	for i in range(len(nums)):
		d[i]=1
		for j in range(i):
			if nums[j]<=nums[i] and (d[j]+1)>d[i]:
				d[i] = d[j]+1

	answer = max(d)
	return answer

if __name__=="__main__":

	data = [5,3,4,8,6,7]
	print LIS(data)


9.最长公共子序列 LCS（longest common sequence） 问题

c[i,j]表示Xi 和 Yj 的LCS的长度

c[i,j]= 0 if(I or j ==0)
      = c[I-1,j-1]+1. If x[I]=y[j]
      = max(c[I-1][j],c[I][j-1]).   If x[I]!=y[j]

def LCS(s1,s2):
	length1 = len(s1)
	length2 = len(s2)

	s1.insert(0,0)
	s2.insert(0,0)

	c = [[0]*(length2+1)]*(length1+1)
	for i in range(1,len(c)):
		for j in range(1,len(c[0])):
			if s1[i]==s2[j]:
				c[i][j] = c[i-1][j-1]+1
			else:
				c[i][j] = max(c[i-1][j],c[i][j-1])

	return c[-1][-1]

if __name__=="__main__":

	s1=[1,3,4,5,6,7,7,8]
	s2=[3,5,7,4,8,6,7,8,2]
	
	print LCS(s1,s2)

10. 





