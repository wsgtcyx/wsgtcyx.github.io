---
layout:     post
title:      C++语法总结
subtitle:   annoying！
date:       2018-03-21
author:     CHEN   Yuxiang
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - C++
---

# part 1 Basis

### 定义一个新的string类
实现构造函数、析构函数、拷贝构造函数、赋值函数

```cpp
class NewString{
public:
    NewString(const char*str=nullptr);//构造函数
    NewString(const NewString& other);//拷贝构造函数
    NewString& operator=(const NewString& other); //赋值函数
    ~NewString(); //析构函数
    
    void show();
private:
    char *m_data;
    
};

NewString::NewString(const char *str){
    if(str==nullptr){
        m_data = new char[1];
        *m_data = '\0';
    }
    else{
        size_t len = strlen(str);
        m_data = new char[len+1];
        strcpy(m_data,str);
    }
}

NewString::NewString(const NewString &other){
    if(m_data) delete [] m_data;
    size_t len = strlen(other.m_data);
    m_data = new char[len+1];
    strcpy(m_data,other.m_data);
}

NewString & NewString::operator=(const NewString &other){
    if(this==&other) return *this;
    size_t len = strlen(other.m_data);
    m_data = new char[len+1];
    strcpy(m_data,other.m_data);
    return *this;
}

NewString::~NewString() { delete []m_data;}

```
### 编写一个标准的strcpy函数

```cpp
char *NewStrcpy(char *strDest,const char*strSrc){
    assert((strDest!=NULL)&&(strSrc!=NULL));
    char *address = strDest;
    while((*strDest++ = *strSrc++)!='\0');
    return address;
}
```
### 分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。

```cpp
//BOOL
if ( !a ) or if(a)
//int
if ( a == 0)  
//float
const EXPRESSION EXP = 0.000001
if ( a < EXP && a >-EXP) 
//pointer
if ( a != NULL) or if(a == NULL)
```


# part1 简述题

### 将“引用”作为函数参数有哪些特点？
（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

### const  与 #define 的比较 ，const有什么优点?

（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。

（2）  有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

















